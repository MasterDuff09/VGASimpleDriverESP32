// main.c
#include <stdio.h>
#include <string.h>

//#include "pattern_handler.h"

/*
L'idea è di fare un resizing della risoluzione VGA da 640x480 a 320x480.
Dimezzando la frequenza di Pixel clock da 25.175 MHz a 12.5875 MHz mantenendo la lunghezza complessiva della riga. 
Tenendo però che tengo la risoluzione verticale al massimo, dimezzo il refresh rate a 30Hz invece che agli standard 60 Hz.
Contando un totale di 400 pixel per riga (320 pixel visibili + 80 pixel di sync) e 525 righe (480 righe visibili + 45 righe di sync)
abbiamo un totale di 400 * 525 = 210000 pixel. Questo sarà la lunghezza del pattern totale del H-sync e V-sync.
Uso direttamente la combinazione di 0/0.7v per i singoli RGB signals, o acceso o spento, perciò in tutto 8 colori.
Per risparmiare memoria, calcolo direttamente il numero di bit complessivi necessari per il controllo preciso dei singoli segnali.
Il tutto salvato nell'array allocato nell'heap, per comandare ogni singolo pixel.
*/

#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "esp_check.h"
#include "driver/i2s_common.h"
#include "sdkconfig.h"

#define I2S_PORT            I2S_NUM_0
#define PIXEL_CLOCK_IO      GPIO_NUM_18   // BCK → pixel clock

static const gpio_num_t data_io[5] = {
    GPIO_NUM_2,   // bit0 → R
    GPIO_NUM_4,   // bit1 → G
    GPIO_NUM_5,   // bit2 → B
    GPIO_NUM_16,  // bit3 → H-SYNC
    GPIO_NUM_17   // bit4 → V-SYNC
};

/*
#include "driver/i2s.h"
#include "driver/gpio.h"
#include "soc/gpio_sig_map.h"  // per I2S0O_DATA_OUT0_IDX, I2S0O_BCK_OUT_IDX, ecc.

#define I2S_PORT            I2S_NUM_0
#define PIXEL_CLOCK_IO      GPIO_NUM_18   // BCK → pixel clock
#define DMA_BUF_COUNT       4             // numero di buffer DMA
#define DMA_BUF_LEN         53200         // dimensione di ciascun buffer (es. 212000/4)
static const gpio_num_t data_io[5] = {
    GPIO_NUM_2,   // bit0 → R
    GPIO_NUM_4,   // bit1 → G
    GPIO_NUM_5,   // bit2 → B
    GPIO_NUM_16,  // bit3 → H-SYNC
    GPIO_NUM_17   // bit4 → V-SYNC
};

void i2s_parallel_init(void)
{
    // 1) configura e installa il driver I2S
    i2s_config_t i2s_cfg = {
        .mode               = I2S_MODE_MASTER | I2S_MODE_TX,
        .sample_rate        = 12587500,                     // pixel clock in Hz
        .bits_per_sample    = I2S_BITS_PER_SAMPLE_8BIT,     // 8 bit per “slot”
        .channel_format     = I2S_CHANNEL_FMT_ONLY_RIGHT,   // mono
        .communication_format = I2S_COMM_FORMAT_STAND_MSB,  // MSB first
        .intr_alloc_flags   = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count      = DMA_BUF_COUNT,
        .dma_buf_len        = DMA_BUF_LEN,                  // in “campioni”
        .use_apll           = true,                         // APLL per 12.5875 MHz preciso
        .tx_desc_auto_clear = true,                         // auto-clear su EOF
        .fixed_mclk         = 0,
    };
    ESP_ERROR_CHECK(i2s_driver_install(I2S_PORT, &i2s_cfg, 0, NULL));  :contentReference[oaicite:0]{index=0}

    // 2) non usiamo i2s_set_pin(), ma mappiamo manualmente con gpio_matrix_out:
    //    BCK → pixel clock
    gpio_matrix_out(PIXEL_CLOCK_IO, I2S0O_BCK_OUT_IDX, false, false);
    //    ciascun bit di dati su data_out0…data_out4
    for (int bit = 0; bit < 5; bit++) {
        gpio_matrix_out(data_io[bit], I2S0O_DATA_OUT0_IDX + bit, false, false);
    }
    // WS (word select) non serve in questo schema, lasciare disconnesso

    // 3) ora potete scrivere in loop i vostri DMA-buffer:
    //    i2s_write(I2S_PORT, buffer, buffer_len_bytes, &bytes_written, portMAX_DELAY);
}
*/


void app_main(void){
    

    //VGAinit();
    //VGAprint();
    
    i2s_chan_handle_t tx_handle;
    /* Get the default channel configuration by the helper macro.
    * This helper macro is defined in `i2s_common.h` and shared by all the I2S communication modes.
    * It can help to specify the I2S role and port ID */
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
    /* Allocate a new TX channel and get the handle of this channel */
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_handle, NULL));
    /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
    * These two helper macros are defined in `i2s_std.h` which can only be used in STD mode.
    * They can help to specify the slot and clock configurations for initialization or updating */
    i2s_std_config_t std_cfg = {
        .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(12587500),
        .slot_cfg = I2S_STD_MSB_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_8BIT, I2S_SLOT_MODE_MONO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = PIXEL_CLOCK_IO,
            .ws = GPIO_NUM_15,
            .dout = GPIO_NUM_2,
            .din = I2S_GPIO_UNUSED,
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv = false,
            },
        },
    };


    /* Initialize the channel */
    

    i2s_channel_init_std_mode(tx_handle, &std_cfg);

    /* Before writing data, start the TX channel first */
    i2s_channel_enable(tx_handle);
    //i2s_channel_write(tx_handle, src_buf, bytes_to_write, bytes_written, ticks_to_wait);

    for (int bit = 0; bit < 5; bit++) {
        gpio_iomux_out(data_io[bit], I2S0O_DATA_OUT0_IDX + bit, false, false);
    }

    /* Have to stop the channel before deleting it */
    i2s_channel_disable(tx_handle);
    /* If the handle is not needed any more, delete it to release the channel resources */
    i2s_del_channel(tx_handle);

    printf("done\n");
    fflush(stdout);
    return;

}



/*

*/